// Use environment variable, fallback to localhost for local development
const GRAPHQL_URL =
  import.meta.env.VITE_GRAPHQL_URL ||
  "http://localhost:4000/graphql";

interface GraphQLResponse<T> {
  data?: T;
  errors?: Array<{
    message: string;
  }>;
}

async function executeGraphQL<T>(
  document: string,
  variables?: Record<string, any>
): Promise<T> {
  const response = await fetch(GRAPHQL_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query: document, variables }),
  });

  if (!response.ok) {
    const body = await response.text();
    throw new Error(`GraphQL request failed (${response.status}): ${body}`);
  }

  let json: GraphQLResponse<T>;
  try {
    json = (await response.json()) as GraphQLResponse<T>;
  } catch {
    throw new Error("Invalid JSON response from GraphQL endpoint");
  }

  if (json.errors?.length) {
    throw new Error(json.errors[0]?.message ?? "Unknown GraphQL error");
  }

  if (!json.data) {
    throw new Error("GraphQL response is missing data");
  }

  return json.data;
}

export async function query<T>(
  queryString: string,
  variables?: Record<string, any>
): Promise<T> {
  return executeGraphQL<T>(queryString, variables);
}

export async function mutate<T>(
  mutationString: string,
  variables?: Record<string, any>
): Promise<T> {
  return executeGraphQL<T>(mutationString, variables);
}

/**
 * GraphQL query for a single wiki file
 */
const GET_WIKI_FILE = `
  query GetWikiFile($project: String!, $fileId: String!) {
    getWikiFile(project: $project, fileId: $fileId) {
      id
      path
      content
    }
  }
`;

/**
 * Fetch wiki file content via GraphQL (custom handler, not using executeGraphQL)
 */
export async function fetchWikiFile(
  project: string,
  id: string
): Promise<string> {
  try {
    const response = await fetch(GRAPHQL_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: GET_WIKI_FILE,
        variables: { project, fileId: id },
      }),
    });

    if (!response.ok) {
      const body = await response.text();
      throw new Error(`GraphQL request failed (${response.status}): ${body}`);
    }

    const json = (await response.json()) as GraphQLResponse<{
      getWikiFile?: { id: string; path: string; content: string };
    }>;

    if (json.errors?.length) {
      throw new Error(json.errors[0]?.message ?? "Unknown GraphQL error");
    }

    const file = json.data?.getWikiFile;
    if (!file) {
      throw new Error(`Wiki file not found: ${id}`);
    }

    return file.content;
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Failed to fetch wiki file";
    throw new Error(message);
  }
}

/**
 * Slugify name for wiki files (matches backend api/wiki.ts)
 */
function slugifyForWiki(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");
}

/**
 * Fetch wiki for entity:
 * 1. Try the graph-backed /wiki-entity endpoint
 * 2. Fall back to /wiki-from-text for extracted entities (with extraction context)
 * 3. Fall back to static wiki markdown generated by batch exporter
 */
export async function fetchEntityWiki(
  project: string,
  entityName: string,
  entityId?: string,
  entityType?: string,
  extractionContext?: { entities: any[]; relations: any[] }
): Promise<string> {
  const params = new URLSearchParams();
  params.set("project", project);
  if (entityId) {
    params.set("entityId", entityId);
  }
  params.set("entityName", entityName);

  // 1) Try live graph-based wiki endpoint
  const res = await fetch(`/wiki-entity?${params.toString()}`);

  if (res.ok) {
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
      const data = await res.json();
      return data.markdown ?? data.wiki ?? "";
    }
    return await res.text();
  }

  // 2) If the wiki-entity endpoint says "not found", try local wiki generation from extracted entity data
  if (res.status === 404) {
    // If we have extraction context, use POST with full data
    if (extractionContext && extractionContext.entities.length > 0) {
      const wikiFromTextRes = await fetch(`/wiki-from-text`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          entityName,
          entityType,
          entities: extractionContext.entities,
          relations: extractionContext.relations,
        }),
      });

      if (wikiFromTextRes.ok) {
        return await wikiFromTextRes.text();
      }
    }

    // Fallback to simple GET request
    const wikiFromTextParams = new URLSearchParams();
    wikiFromTextParams.set("entityName", entityName);
    if (entityType) {
      wikiFromTextParams.set("entityType", entityType);
    }

    const wikiFromTextRes = await fetch(`/wiki-from-text?${wikiFromTextParams.toString()}`);
    if (wikiFromTextRes.ok) {
      return await wikiFromTextRes.text();
    }

    // 3) If /wiki-from-text also fails, try static wiki files
    const slug = slugifyForWiki(entityName);

    // First: try a per-entity wiki file (e.g., "cory.md")
    try {
      return await fetchWikiFile(project, slug);
    } catch (err) {
      const message = err instanceof Error ? err.message : "";
      // If that specific file doesn't exist, fall back to the People index page
      if (message.startsWith("Wiki file not found")) {
        return fetchWikiFile(project, "people");
      }
      throw err;
    }
  }

  // 4) Any other error -> throw a useful message
  let body = "";
  try {
    body = await res.text();
  } catch {
    // ignore
  }

  throw new Error(
    `Failed to fetch entity wiki (HTTP ${res.status}: ${
      body || res.statusText
    })`
  );
}

/**
 * Fetch metrics from HTTP endpoint
 */
export async function fetchMetrics(): Promise<string> {
  try {
    const response = await fetch("/metrics");

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return await response.text();
  } catch (error) {
    const message =
      error instanceof Error ? error.message : "Failed to fetch metrics";
    throw new Error(message);
  }
}

/**
 * Parse Prometheus metrics text into key-value pairs
 */
export function parseMetrics(
  metricsText: string
): Record<string, number> {
  const lines = metricsText.split("\n");
  const metrics: Record<string, number> = {};

  for (const line of lines) {
    if (line.startsWith("#") || line.trim() === "") {
      continue;
    }

    const match = line.match(
      /^([a-zA-Z_][a-zA-Z0-9_]*)\s+([0-9.]+)$/
    );
    if (match) {
      const [, name, value] = match;
      metrics[name] = parseFloat(value);
    }
  }

  return metrics;
}
